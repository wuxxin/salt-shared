#cloud-config
# XXX keep the "#cloud-config" line first and unchanged, software expects this header
{%- if not extra.appliance|d(false) %}
  {%- set dummy=extra.__setitem__('appliance', {}) %}
{%- endif %}
{{ "{% from 'lib/minivault.sls' import manage_secret %}" }}

appliance:
  # # standby: default false, if set appliance will not activate
  # standby: true
  domain: {{ domain }}
  # # sentry:dsn set to your sentry url
{%- if extra.appliance.sentry|d(false) %}
  sentry:
{{ extra.appliance.sentry|yaml(false)|indent(4,True) }}
{%- else %}
  # sentry:
  #   dsn: 'https://url'
{%- endif %}
{%- if extra.appliance.flags|d(false) %}
  # # flags: set or delete flags, for list see appliance/README.md
  flags:
{{ extra.appliance.flags|yaml(false)|indent(4,True) }}
{%- else %}
  # # flags: set or delete flags, for list see appliance/README.md
  # # eg. no-postgres_exporter
  # flags:
  #   enabled:
  #   disabled:
  #   - metric.exporter
  #   - metric.server
  #   - metric.gui
{%- endif %}
{%- if extra.appliance.git|d(false) %}
  git:
{{ extra.appliance.git|yaml(false)|indent(4,True) }}
{%- else %}
  # git:
  #   branch: master
  #   source: git_url
{%- endif %}
{%- if extra.appliance.extra|d(false) and
    extra.appliance.extra.files|d(false) %}
  extra:
    files:
  {%- for f_dict in extra.appliance.extra.files %}
      - path: {{ f_dict.path }}
        content: |
    {%- for l in f_dict.content.split('\\n') %}
            {{ l }}
    {%- endfor %}
    {%- if f_dict.owner|d(false) %}
        owner: {{ f_dict.owner }}
    {%- endif %}
    {%- if f_dict.permissions|d(false) %}
        permissions: {{ f_dict.permissions }}
    {%- endif %}
  {%- endfor %}
{%- else %}
  # extra:
  #   # write out extra files on state.highstate and appliance-prepare
  #   files:
  #     - path: /path/of/filename
  #       content: |
  #           # Your content here
  #       owner: user:group
  #       permissions: "0600"
{%- endif %}
  #   # include extra packages, will be installed on state.highstate and appliance-prepare
  #   packages:
  #     - qrcode
  #   # states: # string to be executed as a salststack sls at state.highstate
  #   # # warning: syntax and execution errors will break initial deployment and appliance-update
  #   states: |
  #       testing:
  #         pkg.installed:
  #           - name: curl
  # # update:oncalendar: # set a different update timer than default: "*-*-* 06:30:00"
  # # update:automatic: # default to true, to disable automatic update set to false
  # # XXX do not update in the time between 00:30 and 06:30 because backup runs at this time
  # # XXX Important: use metric recording and active alert collection if you use automatic update
{%- if extra.appliance.update|d(false) %}
  update:
  {%- if extra.appliance.update.oncalendar|d(false) %}
    oncalendar: {{ extra.appliance.update.oncalendar }}
  {%- endif %}
    automatic: {{ extra.appliance.update.automatic|d(true) }}
{%- else %}
  # update:
  #   automatic: true
  #   oncalendar: Sun *-*-* 06:30:00
{%- endif %}
  storage:
    # mount: # default false, if true: will check and setup volume
    #   volatile: false
    #   data: false
    # setup: # optional, will be executed by appliance.storage.setup if volatile or data can not be found
    # setup: |
    #
  backup:
    url: file:///volatile/backup-test/
    # options: "string of options directly passed to duplicity"
    # # mount default empty, script will mount & unmount source to target on backup run
    # mount:
    #   type: "cifs"
    #   source: "//1.2.3.4/datavolume"
    #   target: "/mnt/appliance-backup-mount"
    #   options: "user=username,pass=password"
    # # options are passed to mount via "-o"
    encrypt: |
{{ "{{ manage_secret('appliance-backup-gpgkey', 'gpg_secret', ownername='appliance-backup')|indent(8,True) }}" }}

