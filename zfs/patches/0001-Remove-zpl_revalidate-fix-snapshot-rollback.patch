From 6ed74b581b208fac5eee954069f5495c7103c3b5 Mon Sep 17 00:00:00 2001
From: Pavel Snajdr <snajpa@snajpa.net>
Date: Fri, 22 Nov 2019 19:37:41 +0100
Subject: [PATCH 01/13] Remove zpl_revalidate: fix snapshot rollback

Open files, which aren't present in the snapshot, which is being
roll-backed to, need to disappear from the visible VFS image of
the dataset.

Kernel provides __d_drop function to locklessly drop invalid entry
from the dcache, but inode can be referenced by multiple dentries.

The introduced spl_d_drop_aliases function walks and invalidates
all aliases of an inode.

Signed-off-by: Pavel Snajdr <snajpa@snajpa.net>
---
 config/kernel-dentry-alias.m4                 | 30 +++++++++++++++++++
 config/kernel.m4                              |  2 ++
 include/os/linux/kernel/linux/dcache_compat.h | 21 +++++++++++++
 include/os/linux/zfs/sys/zpl.h                |  2 ++
 module/os/linux/zfs/zfs_vfsops.c              |  3 ++
 module/os/linux/zfs/zpl_inode.c               |  4 +++
 6 files changed, 62 insertions(+)
 create mode 100644 config/kernel-dentry-alias.m4

diff --git a/config/kernel-dentry-alias.m4 b/config/kernel-dentry-alias.m4
new file mode 100644
index 000000000..f0ddb8d01
--- /dev/null
+++ b/config/kernel-dentry-alias.m4
@@ -0,0 +1,30 @@
+dnl #
+dnl # 3.18 API change
+dnl # Dentry aliases are in d_u struct dentry member
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_DENTRY_ALIAS_D_U], [
+	ZFS_LINUX_TEST_SRC([dentry_alias_d_u], [
+		#include <linux/fs.h>
+		#include <linux/dcache.h>
+		#include <linux/list.h>
+	], [
+		struct inode *inode __attribute__ ((unused)) = NULL;
+		struct dentry *dentry __attribute__ ((unused)) = NULL;
+		hlist_for_each_entry(dentry, &inode->i_dentry,
+		    d_u.d_alias) {
+			d_drop(dentry);
+		}
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_DENTRY_ALIAS_D_U], [
+	AC_MSG_CHECKING([whether dentry aliases are in d_u member])
+	ZFS_LINUX_TEST_RESULT([dentry_alias_d_u], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_DENTRY_D_U_ALIASES, 1,
+		    [dentry aliases are in d_u member])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
diff --git a/config/kernel.m4 b/config/kernel.m4
index c29de3494..3e50fc823 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -88,6 +88,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
 	ZFS_AC_KERNEL_SRC_SETATTR_PREPARE
 	ZFS_AC_KERNEL_SRC_INSERT_INODE_LOCKED
 	ZFS_AC_KERNEL_SRC_DENTRY
+	ZFS_AC_KERNEL_SRC_DENTRY_ALIAS_D_U
 	ZFS_AC_KERNEL_SRC_TRUNCATE_SETSIZE
 	ZFS_AC_KERNEL_SRC_SECURITY_INODE
 	ZFS_AC_KERNEL_SRC_FST_MOUNT
@@ -182,6 +183,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
 	ZFS_AC_KERNEL_SETATTR_PREPARE
 	ZFS_AC_KERNEL_INSERT_INODE_LOCKED
 	ZFS_AC_KERNEL_DENTRY
+	ZFS_AC_KERNEL_DENTRY_ALIAS_D_U
 	ZFS_AC_KERNEL_TRUNCATE_SETSIZE
 	ZFS_AC_KERNEL_SECURITY_INODE
 	ZFS_AC_KERNEL_FST_MOUNT
diff --git a/include/os/linux/kernel/linux/dcache_compat.h b/include/os/linux/kernel/linux/dcache_compat.h
index d0588a82e..e2aca1629 100644
--- a/include/os/linux/kernel/linux/dcache_compat.h
+++ b/include/os/linux/kernel/linux/dcache_compat.h
@@ -61,4 +61,25 @@ d_clear_d_op(struct dentry *dentry)
 	    DCACHE_OP_REVALIDATE | DCACHE_OP_DELETE);
 }
 
+/*
+ * Walk and invalidate all dentry aliases of an inode
+ * unless it's a mountpoint
+ */
+static inline void
+zpl_d_drop_aliases(struct inode *inode)
+{
+	struct dentry *dentry;
+	spin_lock(&inode->i_lock);
+#ifdef HAVE_DENTRY_D_U_ALIASES
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
+#else
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+#endif
+		if (!IS_ROOT(dentry) && !d_mountpoint(dentry) &&
+		    (dentry->d_inode == inode)) {
+			d_drop(dentry);
+		}
+	}
+	spin_unlock(&inode->i_lock);
+}
 #endif /* _ZFS_DCACHE_H */
diff --git a/include/os/linux/zfs/sys/zpl.h b/include/os/linux/zfs/sys/zpl.h
index ef5a0b842..39015ddd7 100644
--- a/include/os/linux/zfs/sys/zpl.h
+++ b/include/os/linux/zfs/sys/zpl.h
@@ -45,7 +45,9 @@ extern const struct inode_operations zpl_inode_operations;
 extern const struct inode_operations zpl_dir_inode_operations;
 extern const struct inode_operations zpl_symlink_inode_operations;
 extern const struct inode_operations zpl_special_inode_operations;
+#if 0
 extern dentry_operations_t zpl_dentry_operations;
+#endif
 
 /* zpl_file.c */
 extern ssize_t zpl_read_common(struct inode *ip, const char *buf,
diff --git a/module/os/linux/zfs/zfs_vfsops.c b/module/os/linux/zfs/zfs_vfsops.c
index b6757d1bc..72c1006bb 100644
--- a/module/os/linux/zfs/zfs_vfsops.c
+++ b/module/os/linux/zfs/zfs_vfsops.c
@@ -1485,7 +1485,9 @@ zfs_domount(struct super_block *sb, zfs_mnt_t *zm, int silent)
 	sb->s_op = &zpl_super_operations;
 	sb->s_xattr = zpl_xattr_handlers;
 	sb->s_export_op = &zpl_export_operations;
+#if 0
 	sb->s_d_op = &zpl_dentry_operations;
+#endif
 
 	/* Set features for file system. */
 	zfs_set_fuid_feature(zfsvfs);
@@ -1838,6 +1840,7 @@ zfs_resume_fs(zfsvfs_t *zfsvfs, dsl_dataset_t *ds)
 	    zp = list_next(&zfsvfs->z_all_znodes, zp)) {
 		err2 = zfs_rezget(zp);
 		if (err2) {
+			zpl_d_drop_aliases(ZTOI(zp));
 			remove_inode_hash(ZTOI(zp));
 			zp->z_is_stale = B_TRUE;
 		}
diff --git a/module/os/linux/zfs/zpl_inode.c b/module/os/linux/zfs/zpl_inode.c
index c1b582574..5ddac6a26 100644
--- a/module/os/linux/zfs/zpl_inode.c
+++ b/module/os/linux/zfs/zpl_inode.c
@@ -613,6 +613,7 @@ out:
 	return (error);
 }
 
+#if 0
 static int
 #ifdef HAVE_D_REVALIDATE_NAMEIDATA
 zpl_revalidate(struct dentry *dentry, struct nameidata *nd)
@@ -652,6 +653,7 @@ zpl_revalidate(struct dentry *dentry, unsigned int flags)
 
 	return (1);
 }
+#endif
 
 const struct inode_operations zpl_inode_operations = {
 	.setattr	= zpl_setattr,
@@ -742,6 +744,8 @@ const struct inode_operations zpl_special_inode_operations = {
 #endif /* CONFIG_FS_POSIX_ACL */
 };
 
+#if 0
 dentry_operations_t zpl_dentry_operations = {
 	.d_revalidate	= zpl_revalidate,
 };
+#endif
-- 
2.20.1

