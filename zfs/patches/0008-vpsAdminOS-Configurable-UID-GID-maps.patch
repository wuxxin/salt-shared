From 6991deacdf9782faae5b234a4af2a757f9548f2a Mon Sep 17 00:00:00 2001
From: Jakub Skokan <jakub.skokan@havefun.cz>
Date: Mon, 14 May 2018 17:22:39 +0200
Subject: [PATCH 08/13] [vpsAdminOS] Configurable UID/GID maps

This patch introduces two new properties: uidmap and gidmap.
These properties are used to map user and group IDs to a different
namespace. The mapping occurs only in memory and what is presented to VFS.
On disk, the IDs are not shifted, which means the map can be changed
at will without chowning all the files within the dataset.

This feature is useful for unprivileged LXC containers that are using
UID/GID mapping. Create the container _without_ any idmap, then
configure the mapping in LXC and set appropriate uidmap and gidmap
on the container's dataset.

For example:

  zfs set uidmap="0:100000:65536" tank/test
  zfs set gidmap="0:100000:65536" tank/test

The commands above will make it so that UID/GID 0-65535 is mapped to
100000-165535. To use this dataset in a user namespace, you could do
something like `newuidmap <pid> 0 100000 65536` or in LXC
`lxc.idmap = u 0 100000 65536` and the same for group IDs.

ZFS checks that the map is syntactically correct and can process up to
10 map entries separated by commas. However, it does not check whether
the mapping makes sense logically, or if there aren't some overlaps. Map
entries are searched for sequentially, first matching entry wins.
---
 configure.ac                                  |   1 +
 include/os/linux/zfs/sys/zfs_vfsops.h         |   3 +
 include/sys/Makefile.am                       |   1 +
 include/sys/fs/zfs.h                          |   2 +
 include/sys/zfs_ugid_map.h                    |  23 +++
 lib/libzfs/libzfs_dataset.c                   |  68 +++++++
 module/os/linux/zfs/Makefile.in               |   1 +
 module/os/linux/zfs/zfs_ugid_map.c            | 183 ++++++++++++++++++
 module/os/linux/zfs/zfs_vfsops.c              |   6 +
 module/os/linux/zfs/zfs_vnops.c               |  17 +-
 module/os/linux/zfs/zfs_znode.c               |  24 ++-
 module/zcommon/zfs_prop.c                     |   6 +
 tests/runfiles/linux.run                      |   4 +
 tests/zfs-tests/tests/functional/Makefile.am  |   1 +
 .../tests/functional/ugid_maps/Makefile.am    |   8 +
 .../tests/functional/ugid_maps/cleanup.ksh    |   6 +
 .../tests/functional/ugid_maps/setup.ksh      |  28 +++
 .../functional/ugid_maps/ugid_maps_001.ksh    |  39 ++++
 .../functional/ugid_maps/ugid_maps_002.ksh    |  90 +++++++++
 .../functional/ugid_maps/ugid_maps_003.ksh    |  39 ++++
 .../functional/ugid_maps/ugid_maps_004.ksh    | 134 +++++++++++++
 21 files changed, 672 insertions(+), 12 deletions(-)
 create mode 100644 include/sys/zfs_ugid_map.h
 create mode 100644 module/os/linux/zfs/zfs_ugid_map.c
 create mode 100644 tests/zfs-tests/tests/functional/ugid_maps/Makefile.am
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/cleanup.ksh
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/setup.ksh
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_001.ksh
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_002.ksh
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_003.ksh
 create mode 100755 tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_004.ksh

diff --git a/configure.ac b/configure.ac
index 0c189e47c..5d4457012 100644
--- a/configure.ac
+++ b/configure.ac
@@ -371,6 +371,7 @@ AC_CONFIG_FILES([
 	tests/zfs-tests/tests/functional/truncate/Makefile
 	tests/zfs-tests/tests/functional/upgrade/Makefile
 	tests/zfs-tests/tests/functional/user_namespace/Makefile
+	tests/zfs-tests/tests/functional/ugid_maps/Makefile
 	tests/zfs-tests/tests/functional/userquota/Makefile
 	tests/zfs-tests/tests/functional/vdev_zaps/Makefile
 	tests/zfs-tests/tests/functional/write_dirs/Makefile
diff --git a/include/os/linux/zfs/sys/zfs_vfsops.h b/include/os/linux/zfs/sys/zfs_vfsops.h
index 20acc2414..b0e666528 100644
--- a/include/os/linux/zfs/sys/zfs_vfsops.h
+++ b/include/os/linux/zfs/sys/zfs_vfsops.h
@@ -37,6 +37,7 @@
 #include <sys/dsl_dataset.h>
 #include <sys/zfs_ioctl.h>
 #include <sys/objlist.h>
+#include <sys/zfs_ugid_map.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -135,6 +136,8 @@ struct zfsvfs {
 	avl_tree_t	*z_hold_trees;	/* znode hold trees */
 	kmutex_t	*z_hold_locks;	/* znode hold locks */
 	taskqid_t	z_drain_task;	/* task id for the unlink drain task */
+	struct zfs_ugid_map    *z_uid_map;
+	struct zfs_ugid_map    *z_gid_map;
 };
 
 #define	ZSB_XATTR	0x0001		/* Enable user xattrs */
diff --git a/include/sys/Makefile.am b/include/sys/Makefile.am
index 82165170a..3493d6199 100644
--- a/include/sys/Makefile.am
+++ b/include/sys/Makefile.am
@@ -114,6 +114,7 @@ COMMON_H = \
 	$(top_srcdir)/include/sys/zfs_stat.h \
 	$(top_srcdir)/include/sys/zfs_sysfs.h \
 	$(top_srcdir)/include/sys/zfs_znode.h \
+	$(top_srcdir)/include/sys/zfs_ugid_map.h \
 	$(top_srcdir)/include/sys/zil.h \
 	$(top_srcdir)/include/sys/zil_impl.h \
 	$(top_srcdir)/include/sys/zio_checksum.h \
diff --git a/include/sys/fs/zfs.h b/include/sys/fs/zfs.h
index 477356aa7..aa20a8c5c 100644
--- a/include/sys/fs/zfs.h
+++ b/include/sys/fs/zfs.h
@@ -186,6 +186,8 @@ typedef enum {
 	ZFS_PROP_IVSET_GUID,		/* not exposed to the user */
 	ZFS_PROP_REDACTED,
 	ZFS_PROP_REDACT_SNAPS,
+	ZFS_PROP_UIDMAP,
+	ZFS_PROP_GIDMAP,
 	ZFS_NUM_PROPS
 } zfs_prop_t;
 
diff --git a/include/sys/zfs_ugid_map.h b/include/sys/zfs_ugid_map.h
new file mode 100644
index 000000000..1d3d2659e
--- /dev/null
+++ b/include/sys/zfs_ugid_map.h
@@ -0,0 +1,23 @@
+#ifndef	_SYS_FS_ZFS_UGID_MAP_H
+#define	_SYS_FS_ZFS_UGID_MAP_H
+
+#define ZFS_UGID_MAP_SIZE 10
+
+struct zfs_ugid_map_entry {
+	uint64_t        e_ns_id;
+	uint64_t        e_host_id;
+	uint64_t        e_count;
+};
+
+struct zfs_ugid_map {
+	struct zfs_ugid_map_entry **m_map;
+	uint64_t        m_size;
+	uint64_t        m_entries;
+};
+
+struct zfs_ugid_map* zfs_create_ugid_map(objset_t *os, zfs_prop_t prop);
+void zfs_free_ugid_map(struct zfs_ugid_map *ugid_map);
+uint64_t zfs_ugid_map_ns_to_host(struct zfs_ugid_map *ugid_map, uint64_t id);
+uint64_t zfs_ugid_map_host_to_ns(struct zfs_ugid_map *ugid_map, uint64_t id);
+
+#endif	/* _SYS_FS_ZFS_UGID_MAP_H */
diff --git a/lib/libzfs/libzfs_dataset.c b/lib/libzfs/libzfs_dataset.c
index 45e7a79fb..a8df54e2c 100644
--- a/lib/libzfs/libzfs_dataset.c
+++ b/lib/libzfs/libzfs_dataset.c
@@ -60,6 +60,7 @@
 #include <sys/spa.h>
 #include <sys/zap.h>
 #include <sys/dsl_crypt.h>
+#include <sys/zfs_ugid_map.h>
 #include <libzfs.h>
 #include <libzutil.h>
 
@@ -991,6 +992,45 @@ zfs_which_resv_prop(zfs_handle_t *zhp, zfs_prop_t *resv_prop)
 	return (0);
 }
 
+static int
+zfs_ugid_map_validate_str(char *strval)
+{
+	int pos = 0, i = 0, entries = 0, matches;
+	int64_t ns_id, host_id, cnt;
+
+	if (strcmp(strval, "none") == 0)
+		return 0;
+
+	while (1) {
+		matches = sscanf(strval + pos, "%ld:%ld:%ld%n",
+				&ns_id, &host_id, &cnt, &i);
+		pos += i;
+
+		if (matches == 0) {
+			if (entries > 0)
+				break;
+			else
+				return 1;
+		} else if (matches != 3) {
+			return 1;
+		}
+
+		if (ns_id < 0 || host_id < 0 || cnt < 1)
+			return 1;
+		else if (strval[pos] == ',')
+			pos += 1;
+		else if (strval[pos] == '\0')
+			return 0;
+		else
+			return 1;
+
+		if (++entries == ZFS_UGID_MAP_SIZE)
+			return 1;
+	}
+
+	return 0;
+}
+
 /*
  * Given an nvlist of properties to set, validates that they are correct, and
  * parses any numeric properties (index, boolean, etc) if they are specified as
@@ -1524,6 +1564,31 @@ badlabel:
 			chosen_normal = (int)intval;
 			break;
 
+		case ZFS_PROP_UIDMAP:
+		case ZFS_PROP_GIDMAP:
+		{
+			if (zfs_ugid_map_validate_str(strval) != 0) {
+				zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
+				    "'%s' is not in the expected format"),
+				    propname);
+				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
+				goto error;
+			}
+
+			if (zhp == NULL)
+				break;
+
+			if (zfs_prop_get_int(zhp, ZFS_PROP_MOUNTED)) {
+				zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
+				    "'%s' cannot be changed while the file "
+				    "system is mounted"), propname);
+				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
+				goto error;
+			}
+
+			break;
+		}
+
 		default:
 			break;
 		}
@@ -3061,6 +3126,9 @@ zfs_prop_get(zfs_handle_t *zhp, zfs_prop_t prop, char *propbuf, size_t proplen,
 		zcp_check(zhp, prop, val, NULL);
 		break;
 
+	//case ZFS_PROP_UIDMAP: // TODO retrieve property
+	//case ZFS_PROP_GIDMAP:
+
 	default:
 		switch (zfs_prop_get_type(prop)) {
 		case PROP_TYPE_NUMBER:
diff --git a/module/os/linux/zfs/Makefile.in b/module/os/linux/zfs/Makefile.in
index 8c11a1ee6..ef43dd4c4 100644
--- a/module/os/linux/zfs/Makefile.in
+++ b/module/os/linux/zfs/Makefile.in
@@ -26,6 +26,7 @@ $(MODULE)-objs += ../os/linux/zfs/zfs_dir.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_file_os.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_ioctl_os.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_sysfs.o
+$(MODULE)-objs += ../os/linux/zfs/zfs_ugid_map.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_vfsops.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_vnops.o
 $(MODULE)-objs += ../os/linux/zfs/zfs_znode.o
diff --git a/module/os/linux/zfs/zfs_ugid_map.c b/module/os/linux/zfs/zfs_ugid_map.c
new file mode 100644
index 000000000..8c33da83c
--- /dev/null
+++ b/module/os/linux/zfs/zfs_ugid_map.c
@@ -0,0 +1,183 @@
+#include <sys/types.h>
+#include <sys/fs/zfs.h>
+#include <sys/dsl_prop.h>
+#include <sys/dsl_dataset.h>
+#include <sys/zap.h>
+#include <sys/dmu_objset.h>
+#include <sys/zfs_ugid_map.h>
+
+
+struct zfs_ugid_map*
+zfs_create_ugid_map(objset_t *os, zfs_prop_t prop)
+{
+	char *value = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);
+        char source[ZFS_MAX_DATASET_NAME_LEN] = "Internal error - setpoint not determined";
+	uint32_t ns_id, host_id, count;
+	int pos = 0, i = 0, error;
+	struct zfs_ugid_map *ugid_map;
+	struct zfs_ugid_map_entry *entry;
+
+	dsl_pool_config_enter(dmu_objset_pool(os), FTAG);
+
+	error = dsl_prop_get_ds(os->os_dsl_dataset, zfs_prop_to_name(prop), 1,
+	    ZAP_MAXVALUELEN, value, source);
+
+	dsl_pool_config_exit(dmu_objset_pool(os), FTAG);
+
+	if (error != 0) {
+		kmem_free(value, ZAP_MAXVALUELEN);
+		/*
+		 * TODO: should we report error? we'd have to pass the return
+		 * value through function argument to be able to report errors
+		 */
+		return NULL;
+		//return (error);
+	}
+
+	if (strcmp(value, "none") == 0)
+		return NULL;
+
+	ugid_map = vmem_zalloc(sizeof(struct zfs_ugid_map), KM_SLEEP);
+	ugid_map->m_size = ZFS_UGID_MAP_SIZE;
+	ugid_map->m_entries = 0;
+	ugid_map->m_map = vmem_zalloc(sizeof(struct zfs_ugid_map_entry*) * ugid_map->m_size,
+			KM_SLEEP);
+
+	while (1) {
+		error = sscanf(value + pos, "%u:%u:%u%n", &ns_id, &host_id, &count, &i);
+		pos += i;
+
+		if (error == 0) {
+			break;
+
+		} else if (error != 3) {
+#ifdef DEBUG
+			printk("invalid ugid map format");
+#endif
+			return NULL;
+			//return (error);
+		}
+#ifdef DEBUG
+		printk("got map: ns_id=%u, host_id=%u,, count=%u for %s", ns_id, host_id, count, source);
+#endif
+
+		entry = vmem_zalloc(sizeof(struct zfs_ugid_map_entry), KM_SLEEP);
+		entry->e_ns_id = ns_id;
+		entry->e_host_id = host_id;
+		entry->e_count = count;
+
+		ugid_map->m_map[ugid_map->m_entries] = entry;
+		ugid_map->m_entries += 1;
+
+		// TODO: make map size dynamic
+		if (ugid_map->m_entries == ZFS_UGID_MAP_SIZE)
+			break;
+		else if (value[pos] == ',')
+			pos += 1;
+		else
+			break;
+	}
+
+	if (ugid_map->m_entries == 0) {
+		vmem_free(ugid_map->m_map, sizeof(struct zfs_ugid_map_entry*) * ugid_map->m_size);
+		vmem_free(ugid_map, sizeof(struct zfs_ugid_map));
+		return NULL;
+	}
+
+	kmem_free(value, ZAP_MAXVALUELEN);
+	return ugid_map;
+}
+
+void
+zfs_free_ugid_map(struct zfs_ugid_map *ugid_map)
+{
+	int i;
+
+	if (ugid_map == NULL)
+		return;
+
+	for (i = 0; i < ugid_map->m_size; i++) {
+		vmem_free(ugid_map->m_map[i], sizeof(struct zfs_ugid_map_entry));
+	}
+
+	vmem_free(ugid_map->m_map, sizeof(struct zfs_ugid_map_entry*) * ugid_map->m_size);
+	vmem_free(ugid_map, sizeof(struct zfs_ugid_map));
+}
+
+uint64_t
+zfs_ugid_map_ns_to_host(struct zfs_ugid_map *ugid_map, uint64_t id)
+{
+	uint64_t res;
+	int i;
+	struct zfs_ugid_map_entry *entry;
+
+	if (ugid_map == NULL)
+		return id;
+
+	/* look for a matching mapping */
+	for (i = 0; i < ugid_map->m_entries; i++) {
+		entry = ugid_map->m_map[i];
+
+		/* check if we're already mapped into the entry */
+		if (id >= entry->e_host_id && id < (entry->e_host_id + entry->e_count)) {
+#ifdef DEBUG
+			printk("zfs_ugid_map_ns_to_host: %lld already mapped via mapping %lld:%lld:%lld",
+				id, entry->e_ns_id, entry->e_host_id, entry->e_count);
+#endif
+			return id;
+		}
+
+		/* check if we can map the entry */
+		if (id >= entry->e_ns_id && id < (entry->e_ns_id + entry->e_count)) {
+			res = entry->e_host_id + (id - entry->e_ns_id);
+#ifdef DEBUG
+			printk("zfs_ugid_map_ns_to_host: %lld -> %lld via mapping %lld:%lld:%lld",
+				id, res, entry->e_ns_id, entry->e_host_id, entry->e_count);
+#endif
+			VERIFY3U(0, <=, res);
+			return res;
+		}
+	}
+
+	/* id not mapped, return nobody */
+	return 65534;
+}
+
+uint64_t
+zfs_ugid_map_host_to_ns(struct zfs_ugid_map *ugid_map, uint64_t id)
+{
+	uint64_t res;
+	int i;
+	struct zfs_ugid_map_entry *entry;
+
+	if (ugid_map == NULL)
+		return id;
+
+	/* look for a matching mapping */
+	for (i = 0; i < ugid_map->m_entries; i++) {
+		entry = ugid_map->m_map[i];
+
+		/* check if we're already mapped into the entry */
+		if (id >= entry->e_ns_id && id < (entry->e_ns_id + entry->e_count)) {
+#ifdef DEBUG
+			printk("zfs_ugid_map_host_to_ns: %lld already mapped via mapping %lld:%lld:%lld",
+				id, entry->e_ns_id, entry->e_host_id, entry->e_count);
+#endif
+			return id;
+		}
+
+		/* check if we can map the entry */
+		if (id >= entry->e_host_id && id < (entry->e_host_id + entry->e_count)) {
+			res = (id - entry->e_host_id) + entry->e_ns_id;
+#ifdef DEBUG
+			printk("zfs_ugid_map_host_to_ns: %lld -> %lld via mapping %lld:%lld:%lld",
+				id, res, entry->e_ns_id, entry->e_host_id, entry->e_count);
+#endif
+			VERIFY3U(0, <=, res);
+			return res;
+		}
+	}
+
+	/* id not mapped, return nobody */
+	return 65534;
+}
diff --git a/module/os/linux/zfs/zfs_vfsops.c b/module/os/linux/zfs/zfs_vfsops.c
index 72c1006bb..32e3bba40 100644
--- a/module/os/linux/zfs/zfs_vfsops.c
+++ b/module/os/linux/zfs/zfs_vfsops.c
@@ -60,6 +60,7 @@
 #include <sys/objlist.h>
 #include <sys/zpl.h>
 #include <linux/vfs_compat.h>
+#include <sys/zfs_ugid_map.h>
 #include "zfs_comutil.h"
 
 enum {
@@ -655,6 +656,9 @@ zfsvfs_init(zfsvfs_t *zfsvfs, objset_t *os)
 		return (error);
 	zfsvfs->z_acl_type = (uint_t)val;
 
+	zfsvfs->z_uid_map = zfs_create_ugid_map(zfsvfs->z_os, ZFS_PROP_UIDMAP);
+	zfsvfs->z_gid_map = zfs_create_ugid_map(zfsvfs->z_os, ZFS_PROP_GIDMAP);
+
 	/*
 	 * Fold case on file systems that are always or sometimes case
 	 * insensitive.
@@ -949,6 +953,8 @@ zfsvfs_free(zfsvfs_t *zfsvfs)
 	}
 	vmem_free(zfsvfs->z_hold_trees, sizeof (avl_tree_t) * size);
 	vmem_free(zfsvfs->z_hold_locks, sizeof (kmutex_t) * size);
+	zfs_free_ugid_map(zfsvfs->z_uid_map);
+	zfs_free_ugid_map(zfsvfs->z_gid_map);
 	zfsvfs_vfs_free(zfsvfs->z_vfs);
 	dataset_kstats_destroy(&zfsvfs->z_kstat);
 	kmem_free(zfsvfs, sizeof (zfsvfs_t));
diff --git a/module/os/linux/zfs/zfs_vnops.c b/module/os/linux/zfs/zfs_vnops.c
index 3a96b25b9..972317ea5 100644
--- a/module/os/linux/zfs/zfs_vnops.c
+++ b/module/os/linux/zfs/zfs_vnops.c
@@ -2675,6 +2675,7 @@ zfs_setattr(znode_t *zp, vattr_t *vap, int flags, cred_t *cr)
 	int		trim_mask = 0;
 	uint64_t	new_mode;
 	uint64_t	new_kuid = 0, new_kgid = 0, new_uid, new_gid;
+	uint64_t        stored_uid, stored_gid, offset_uid, offset_gid;
 	uint64_t	xattr_obj;
 	uint64_t	mtime[2], ctime[2], atime[2];
 	uint64_t	projid = ZFS_INVALID_PROJID;
@@ -3182,10 +3183,14 @@ top:
 	if (mask & (ATTR_UID|ATTR_GID)) {
 
 		if (mask & ATTR_UID) {
-			ZTOI(zp)->i_uid = SUID_TO_KUID(new_kuid);
+			stored_uid = zfs_ugid_map_host_to_ns(zfsvfs->z_uid_map, new_kuid);
+			offset_uid = zfs_ugid_map_ns_to_host(zfsvfs->z_uid_map, new_kuid);
+
+			ZTOI(zp)->i_uid = SUID_TO_KUID(offset_uid);
 			new_uid = zfs_uid_read(ZTOI(zp));
+
 			SA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,
-			    &new_uid, sizeof (new_uid));
+			    &stored_uid, sizeof (stored_uid));
 			if (attrzp) {
 				SA_ADD_BULK_ATTR(xattr_bulk, xattr_count,
 				    SA_ZPL_UID(zfsvfs), NULL, &new_uid,
@@ -3195,10 +3200,14 @@ top:
 		}
 
 		if (mask & ATTR_GID) {
-			ZTOI(zp)->i_gid = SGID_TO_KGID(new_kgid);
+			stored_gid = zfs_ugid_map_host_to_ns(zfsvfs->z_gid_map, new_kgid);
+			offset_gid = zfs_ugid_map_ns_to_host(zfsvfs->z_gid_map, new_kgid);
+
+			ZTOI(zp)->i_gid = SGID_TO_KGID(offset_gid);
 			new_gid = zfs_gid_read(ZTOI(zp));
+
 			SA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs),
-			    NULL, &new_gid, sizeof (new_gid));
+			    NULL, &stored_gid, sizeof (stored_gid));
 			if (attrzp) {
 				SA_ADD_BULK_ATTR(xattr_bulk, xattr_count,
 				    SA_ZPL_GID(zfsvfs), NULL, &new_gid,
diff --git a/module/os/linux/zfs/zfs_znode.c b/module/os/linux/zfs/zfs_znode.c
index 9befc07c6..96b93ef86 100644
--- a/module/os/linux/zfs/zfs_znode.c
+++ b/module/os/linux/zfs/zfs_znode.c
@@ -509,6 +509,7 @@ zfs_inode_update(znode_t *zp)
 
 	dmu_object_size_from_db(sa_get_db(zp->z_sa_hdl), &blksize, &i_blocks);
 
+
 	spin_lock(&ip->i_lock);
 	ip->i_blocks = i_blocks;
 	i_size_write(ip, zp->z_size);
@@ -595,8 +596,10 @@ zfs_znode_alloc(zfsvfs_t *zfsvfs, dmu_buf_t *db, int blksz,
 	ip->i_generation = (uint32_t)tmp_gen;
 	ip->i_blkbits = SPA_MINBLOCKSHIFT;
 	set_nlink(ip, (uint32_t)links);
-	zfs_uid_write(ip, z_uid);
-	zfs_gid_write(ip, z_gid);
+
+	zfs_uid_write(ip, zfs_ugid_map_ns_to_host(zfsvfs->z_uid_map, z_uid));
+	zfs_gid_write(ip, zfs_ugid_map_ns_to_host(zfsvfs->z_gid_map, z_gid));
+
 	zfs_set_inode_flags(zp, ip);
 
 	/* Cache the xattr parent id */
@@ -676,6 +679,7 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 	uint64_t	crtime[2], atime[2], mtime[2], ctime[2];
 	uint64_t	mode, size, links, parent, pflags;
 	uint64_t	projid = ZFS_DEFAULT_PROJID;
+	uint64_t        offset_uid, offset_gid;
 	uint64_t	rdev = 0;
 	zfsvfs_t	*zfsvfs = ZTOZSB(dzp);
 	dmu_buf_t	*db;
@@ -797,6 +801,9 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 			pflags |= ZFS_PROJINHERIT;
 	}
 
+	offset_uid = zfs_ugid_map_host_to_ns(zfsvfs->z_uid_map, acl_ids->z_fuid);
+	offset_gid = zfs_ugid_map_host_to_ns(zfsvfs->z_gid_map, acl_ids->z_fgid);
+
 	/*
 	 * No execs denied will be determined when zfs_mode_compute() is called.
 	 */
@@ -856,9 +863,9 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GEN(zfsvfs),
 		    NULL, &gen, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs),
-		    NULL, &acl_ids->z_fuid, 8);
+		    NULL, &offset_uid, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs),
-		    NULL, &acl_ids->z_fgid, 8);
+		    NULL, &offset_gid, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PARENT(zfsvfs),
 		    NULL, &parent, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),
@@ -892,9 +899,9 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),
 		    NULL, &pflags, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs), NULL,
-		    &acl_ids->z_fuid, 8);
+		    &offset_uid, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs), NULL,
-		    &acl_ids->z_fgid, 8);
+		    &offset_gid, 8);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PAD(zfsvfs), NULL, pad,
 		    sizeof (uint64_t) * 4);
 		SA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ZNODE_ACL(zfsvfs), NULL,
@@ -1267,8 +1274,9 @@ zfs_rezget(znode_t *zp)
 
 	zp->z_projid = projid;
 	zp->z_mode = ZTOI(zp)->i_mode = mode;
-	zfs_uid_write(ZTOI(zp), z_uid);
-	zfs_gid_write(ZTOI(zp), z_gid);
+
+	zfs_uid_write(ZTOI(zp), zfs_ugid_map_ns_to_host(zfsvfs->z_uid_map, z_uid));
+	zfs_gid_write(ZTOI(zp), zfs_ugid_map_ns_to_host(zfsvfs->z_gid_map, z_gid));
 
 	ZFS_TIME_DECODE(&ZTOI(zp)->i_atime, atime);
 	ZFS_TIME_DECODE(&ZTOI(zp)->i_mtime, mtime);
diff --git a/module/zcommon/zfs_prop.c b/module/zcommon/zfs_prop.c
index 3ba3b8a84..30aeccda1 100644
--- a/module/zcommon/zfs_prop.c
+++ b/module/zcommon/zfs_prop.c
@@ -498,6 +498,12 @@ zfs_prop_init(void)
 	    "redact_snaps", NULL, PROP_READONLY,
 	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<snapshot>[,...]",
 	    "RSNAPS");
+	zprop_register_string(ZFS_PROP_UIDMAP, "uidmap",
+	    "none", PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
+	    "<map> | none", "UIDMAP");
+	zprop_register_string(ZFS_PROP_GIDMAP, "gidmap",
+	    "none", PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
+	    "<map> | none", "GIDMAP");
 
 	/* readonly number properties */
 	zprop_register_number(ZFS_PROP_USED, "used", 0, PROP_READONLY,
diff --git a/tests/runfiles/linux.run b/tests/runfiles/linux.run
index ab137e34c..108a41c14 100644
--- a/tests/runfiles/linux.run
+++ b/tests/runfiles/linux.run
@@ -160,6 +160,10 @@ tests = ['tmpfile_001_pos', 'tmpfile_002_pos', 'tmpfile_003_pos',
     'tmpfile_stat_mode']
 tags = ['functional', 'tmpfile']
 
+[tests/functional/ugid_maps:Linux]
+tests = ['ugid_maps_001', 'ugid_maps_002', 'ugid_maps_003', 'ugid_maps_004']
+tags = ['functional', 'cli_root']
+
 [tests/functional/upgrade:Linux]
 tests = ['upgrade_projectquota_001_pos']
 tags = ['functional', 'upgrade']
diff --git a/tests/zfs-tests/tests/functional/Makefile.am b/tests/zfs-tests/tests/functional/Makefile.am
index 111ffb29a..4399ada2a 100644
--- a/tests/zfs-tests/tests/functional/Makefile.am
+++ b/tests/zfs-tests/tests/functional/Makefile.am
@@ -76,6 +76,7 @@ SUBDIRS = \
 	threadsappend \
 	trim \
 	truncate \
+	ugid_maps \
 	upgrade \
 	user_namespace \
 	userquota \
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/Makefile.am b/tests/zfs-tests/tests/functional/ugid_maps/Makefile.am
new file mode 100644
index 000000000..5d6ac6757
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/Makefile.am
@@ -0,0 +1,8 @@
+pkgdatadir = $(datadir)/@PACKAGE@/zfs-tests/tests/functional/ugid_maps
+dist_pkgdata_SCRIPTS = \
+	setup.ksh \
+	cleanup.ksh \
+	ugid_maps_001.ksh \
+	ugid_maps_002.ksh \
+	ugid_maps_003.ksh \
+	ugid_maps_004.ksh
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/cleanup.ksh b/tests/zfs-tests/tests/functional/ugid_maps/cleanup.ksh
new file mode 100755
index 000000000..76a418268
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/cleanup.ksh
@@ -0,0 +1,6 @@
+#!/bin/ksh -p
+. $STF_SUITE/include/libtest.shlib
+
+log_must destroy_pool $TESTPOOL
+log_must userdel zfsugidmap
+log_pass
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/setup.ksh b/tests/zfs-tests/tests/functional/ugid_maps/setup.ksh
new file mode 100755
index 000000000..82e714d0f
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/setup.ksh
@@ -0,0 +1,28 @@
+#!/bin/ksh -p
+
+. $STF_SUITE/include/libtest.shlib
+
+DISK=${DISKS%% *}
+create_pool $TESTPOOL "$DISK"
+
+log_must zfs create $TESTPOOL/$TESTFS
+log_must zfs create $TESTPOOL/$TESTFS/both
+log_must zfs create $TESTPOOL/$TESTFS/both/child
+log_must zfs create $TESTPOOL/$TESTFS/uid
+log_must zfs create $TESTPOOL/$TESTFS/uid/child
+log_must zfs create $TESTPOOL/$TESTFS/gid
+log_must zfs create $TESTPOOL/$TESTFS/gid/child
+log_must zfs create $TESTPOOL/$TESTFS/multimap
+
+ZFS_USER=zfsugidmap
+TEST_UID=100000
+TEST_GID=200000
+
+log_must groupadd -g $TEST_GID $ZFS_USER
+log_must useradd -c "ZFS UID/GID Mapping Test User" -u $TEST_UID -g $TEST_GID $ZFS_USER
+
+echo $ZFS_USER > /tmp/zfs-ugid-map-test-user.txt
+echo $TEST_UID > /tmp/zfs-ugid-map-test-uid.txt
+echo $TEST_GID > /tmp/zfs-ugid-map-test-gid.txt
+
+log_pass
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_001.ksh b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_001.ksh
new file mode 100755
index 000000000..f2000796a
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_001.ksh
@@ -0,0 +1,39 @@
+#!/bin/ksh -p
+. $STF_SUITE/include/libtest.shlib
+
+ZFS_USER=$(cat /tmp/zfs-ugid-map-test-user.txt)
+TEST_UID=$(cat /tmp/zfs-ugid-map-test-uid.txt)
+TEST_GID=$(cat /tmp/zfs-ugid-map-test-gid.txt)
+
+[ $(get_prop uidmap $TESTPOOL) == "none" ] || \
+    log_fail "uidmap does not default to none"
+[ $(get_prop gidmap $TESTPOOL) == "none" ] || \
+    log_fail "gidmap does not default to none"
+
+POOLDIR=$(get_prop mountpoint $TESTPOOL)
+
+log_must touch "$POOLDIR/test.txt"
+[ $(stat -c %u:%g "$POOLDIR/test.txt") == "0:0" ] || \
+    log_fail "maps UIDs/GIDs by default"
+
+log_must chown 50000:60000 "$POOLDIR/test.txt"
+[ $(stat -c %u:%g "$POOLDIR/test.txt") == "50000:60000" ] || \
+    log_fail "maps UIDs/GIDs by default"
+
+log_must mkdir "$POOLDIR/userdir"
+log_must chown $TEST_UID:$TEST_GID "$POOLDIR/userdir"
+log_must su $ZFS_USER -c "touch '$POOLDIR/userdir/test.txt'"
+[ $(stat -c %u:%g "$POOLDIR/userdir/test.txt") == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "maps UIDs/GIDs by default"
+
+# TO TEST:
+# default property values
+# does not alter uids/gids by default
+# cannot change properties while mounted
+# can change while unmounted
+# shifts uids/gids
+# access/read from within/without of the UID/GID range
+# maps can be changed
+# sending data stream without maps
+
+log_pass
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_002.ksh b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_002.ksh
new file mode 100755
index 000000000..f11b4a1c4
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_002.ksh
@@ -0,0 +1,90 @@
+#!/bin/ksh -p
+. $STF_SUITE/include/libtest.shlib
+
+ZFS_USER=$(cat /tmp/zfs-ugid-map-test-user.txt)
+TEST_UID=$(cat /tmp/zfs-ugid-map-test-uid.txt)
+TEST_GID=$(cat /tmp/zfs-ugid-map-test-gid.txt)
+
+FSDIR=$(get_prop mountpoint $TESTPOOL/$TESTFS)
+
+# uidmap and gidmap can be changed only when the fs is not mounted
+log_mustnot zfs set uidmap="0:100000:65536" $TESTPOOL/$TESTFS/both
+log_mustnot zfs set gidmap="0:200000:65536" $TESTPOOL/$TESTFS/both
+log_must zfs unmount $TESTPOOL/$TESTFS/both
+
+# input checks
+for prop in uidmap gidmap ; do
+    log_mustnot zfs set ${prop}="" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="something" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="0" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="-1234" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234," $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234,4567" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234,4567" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4567" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:aha" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="aha:1234" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4657:" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4657:aha" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4657:0" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4657:-1" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="-1:-1:-1" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="0:0:0" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234:4657:1," $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}="1234 : 4657 : 1" $TESTPOOL/$TESTFS/both
+    log_mustnot zfs set ${prop}=" 1234:4657:1 " $TESTPOOL/$TESTFS/both
+
+    log_must zfs set ${prop}="none" $TESTPOOL/$TESTFS/both
+    log_must zfs set ${prop}="1234:4657:1" $TESTPOOL/$TESTFS/both
+    log_must zfs set ${prop}="1234:4657:1,5678:9876:2" $TESTPOOL/$TESTFS/both
+done
+
+# set a valid map
+log_must zfs set uidmap="0:100000:65536" $TESTPOOL/$TESTFS/both
+log_must zfs set gidmap="0:200000:65536" $TESTPOOL/$TESTFS/both
+log_must zfs mount $TESTPOOL/$TESTFS/both
+
+# both properties should be inheritable
+[ $(get_prop uidmap $TESTPOOL/$TESTFS/both/child) == "0:100000:65536" ] || \
+    log_fail "uidmap is not inherited"
+[ $(get_prop gidmap $TESTPOOL/$TESTFS/both/child) == "0:200000:65536" ] || \
+    log_fail "gidmap is not inherited"
+
+# accessing the fs with a user with uid/gid outside the map
+log_must touch "$FSDIR/both/test.txt"
+owner=$(stat -c %u:%g "$FSDIR/both/test.txt")
+[ "$owner" == "100000:200000" ] || \
+    log_fail "does not map UIDs/GIDs for new files: expected 100000:200000, got $owner"
+
+log_must chown 500:600 "$FSDIR/both/test.txt"
+owner=$(stat -c %u:%g "$FSDIR/both/test.txt")
+[ "$owner" == "$((500+100000)):$((600+200000))" ] || \
+    log_fail "maps UIDs/GIDs in setattr: expected $((500+100000)):$((600+200000)), got $owner"
+
+# accessing the fs with a user with uid/gid from the map
+log_must mkdir "$FSDIR/both/userdir"
+log_must chown $TEST_UID:$TEST_GID "$FSDIR/both/userdir"
+owner=$(stat -c %u:%g "$FSDIR/both/userdir")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+log_must su $ZFS_USER -c "touch '$FSDIR/both/userdir/test.txt'"
+owner=$(stat -c %u:%g "$FSDIR/both/userdir/test.txt")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+log_must zfs unmount $TESTPOOL/$TESTFS/both
+log_must zfs set uidmap=none gidmap=none $TESTPOOL/$TESTFS/both
+log_must zfs mount $TESTPOOL/$TESTFS/both
+
+owner=$(stat -c %u:%g "$FSDIR/both/test.txt")
+[ "$owner" == "500:600" ] || \
+    log_fail "UID/GID is persisted mapped: expected 500:600, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/both/userdir/test.txt")
+[ "$owner" == "$(($TEST_UID-100000)):$(($TEST_GID-200000))" ] || \
+    log_fail "UID/GID is persisted mapped: expected $(($TEST_UID-100000)):$(($TEST_GID-200000))"
+
+log_pass
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_003.ksh b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_003.ksh
new file mode 100755
index 000000000..80cdb9174
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_003.ksh
@@ -0,0 +1,39 @@
+#!/bin/ksh -p
+. $STF_SUITE/include/libtest.shlib
+
+ZFS_USER=$(cat /tmp/zfs-ugid-map-test-user.txt)
+TEST_UID=$(cat /tmp/zfs-ugid-map-test-uid.txt)
+TEST_GID=$(cat /tmp/zfs-ugid-map-test-gid.txt)
+FSDIR=$(get_prop mountpoint $TESTPOOL/$TESTFS)
+
+log_must zfs unmount $TESTPOOL/$TESTFS/both
+log_must zfs set uidmap="0:100000:65536" $TESTPOOL/$TESTFS/both
+log_must zfs set gidmap="0:200000:65536" $TESTPOOL/$TESTFS/both
+log_must zfs mount $TESTPOOL/$TESTFS/both
+log_must zfs create $TESTPOOL/$TESTFS/both.noprop
+log_must zfs create $TESTPOOL/$TESTFS/both.withprop
+log_must zfs snapshot $TESTPOOL/$TESTFS/both@snap
+
+log_must zfs send $TESTPOOL/$TESTFS/both@snap | zfs recv -F $TESTPOOL/$TESTFS/both.noprop
+owner=$(stat -c %u:%g "$FSDIR/both.noprop/test.txt")
+[ "$owner" == "500:600" ] || \
+    log_fail "UID/GID is persisted mapped: expected 500:600, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/both.noprop/userdir/test.txt")
+[ "$owner" == "$(($TEST_UID-100000)):$(($TEST_GID-200000))" ] || \
+    log_fail "UID/GID is persisted mapped: expected $(($TEST_UID-100000)):$(($TEST_GID-200000))"
+
+log_must zfs send -p $TESTPOOL/$TESTFS/both@snap | zfs recv -F $TESTPOOL/$TESTFS/both.withprop
+owner=$(stat -c %u:%g "$FSDIR/both.withprop/test.txt")
+[ "$owner" == "$((500+100000)):$((600+200000))" ] || \
+    log_fail "maps UIDs/GIDs in setattr: expected $((500+100000)):$((600+200000)), got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/both.withprop/userdir")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/both.withprop/userdir/test.txt")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+log_pass
diff --git a/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_004.ksh b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_004.ksh
new file mode 100755
index 000000000..d67668935
--- /dev/null
+++ b/tests/zfs-tests/tests/functional/ugid_maps/ugid_maps_004.ksh
@@ -0,0 +1,134 @@
+#!/bin/ksh -p
+. $STF_SUITE/include/libtest.shlib
+
+ZFS_USER=$(cat /tmp/zfs-ugid-map-test-user.txt)
+TEST_UID=$(cat /tmp/zfs-ugid-map-test-uid.txt)
+TEST_GID=$(cat /tmp/zfs-ugid-map-test-gid.txt)
+
+FSDIR=$(get_prop mountpoint $TESTPOOL/$TESTFS/multimap)
+
+UIDMAP="0:100000:10000,10000:10000:10000,20000:20000:10000,30000:120000:45536"
+GIDMAP="0:200000:10000,10000:10000:10000,20000:20000:10000,30000:220000:45536"
+
+log_must zfs unmount $TESTPOOL/$TESTFS/multimap
+log_must zfs set uidmap="$UIDMAP" $TESTPOOL/$TESTFS/multimap
+log_must zfs set gidmap="$GIDMAP" $TESTPOOL/$TESTFS/multimap
+log_must zfs mount $TESTPOOL/$TESTFS/multimap
+
+### Accessing the fs with a user with uid/gid outside the map
+log_must touch "$FSDIR/f01.txt"
+owner=$(stat -c %u:%g "$FSDIR/f01.txt")
+[ "$owner" == "100000:200000" ] || \
+    log_fail "does not map UIDs/GIDs for new files: expected 100000:200000, got $owner"
+
+log_must chown 500:600 "$FSDIR/f01.txt"
+owner=$(stat -c %u:%g "$FSDIR/f01.txt")
+[ "$owner" == "$((500+100000)):$((600+200000))" ] || \
+    log_fail "maps UIDs/GIDs in setattr: expected $((500+100000)):$((600+200000)), got $owner"
+
+### Accessing the fs with a user with uid/gid from the map, testing boundaries
+#### of all map entries
+# First map entry
+log_must mkdir "$FSDIR/dir"
+log_must chown $TEST_UID:$TEST_GID "$FSDIR/dir"
+owner=$(stat -c %u:%g "$FSDIR/dir")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+log_must su $ZFS_USER -c "touch '$FSDIR/dir/first_start.txt'"
+owner=$(stat -c %u:%g "$FSDIR/dir/first_start.txt")
+[ "$owner" == "$TEST_UID:$TEST_GID" ] || \
+    log_fail "does not map UIDs/GIDs: expected $TEST_UID:$TEST_GID, got $owner"
+
+log_must touch $FSDIR/dir/first_end.txt
+log_must chown 109999:209999 $FSDIR/dir/first_end.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/first_end.txt")
+[ "$owner" == "109999:209999" ] || \
+    log_fail "does not map UIDs/GIDs: expected 109999:209999, got $owner"
+
+# Second map entry
+log_must touch $FSDIR/dir/second_start.txt
+log_must chown 10000:10000 $FSDIR/dir/second_start.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/second_start.txt")
+[ "$owner" == "10000:10000" ] || \
+    log_fail "does not map UIDs/GIDs: expected 10000:10000, got $owner"
+
+log_must touch $FSDIR/dir/second_end.txt
+log_must chown 19999:19999 $FSDIR/dir/second_end.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/second_end.txt")
+[ "$owner" == "19999:19999" ] || \
+    log_fail "does not map UIDs/GIDs: expected 19999:19999, got $owner"
+
+# Third map entry
+log_must touch $FSDIR/dir/third_start.txt
+log_must chown 20000:20000 $FSDIR/dir/third_start.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/third_start.txt")
+[ "$owner" == "20000:20000" ] || \
+    log_fail "does not map UIDs/GIDs: expected 20000:20000, got $owner"
+
+log_must touch $FSDIR/dir/third_end.txt
+log_must chown 29999:29999 $FSDIR/dir/third_end.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/third_end.txt")
+[ "$owner" == "29999:29999" ] || \
+    log_fail "does not map UIDs/GIDs: expected 29999:29999, got $owner"
+
+# Last map entry
+log_must touch $FSDIR/dir/last_start.txt
+log_must chown 30000:30000 $FSDIR/dir/last_start.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/last_start.txt")
+[ "$owner" == "120000:220000" ] || \
+    log_fail "does not map UIDs/GIDs: expected 120000:220000, got $owner"
+
+log_must touch $FSDIR/dir/last_end.txt
+log_must chown 65535:65535 $FSDIR/dir/last_end.txt
+owner=$(stat -c %u:%g "$FSDIR/dir/last_end.txt")
+[ "$owner" == "155535:255535" ] || \
+    log_fail "does not map UIDs/GIDs: expected 155535:255535, got $owner"
+
+
+### Test that mapped uid/gids are not persisted
+log_must zfs unmount $TESTPOOL/$TESTFS/multimap
+log_must zfs set uidmap=none gidmap=none $TESTPOOL/$TESTFS/multimap
+log_must zfs mount $TESTPOOL/$TESTFS/multimap
+
+owner=$(stat -c %u:%g "$FSDIR/f01.txt")
+[ "$owner" == "500:600" ] || \
+    log_fail "UID/GID is persisted mapped: expected 500:600, got $owner"
+
+# First map entry
+owner=$(stat -c %u:%g "$FSDIR/dir/first_start.txt")
+[ "$owner" == "0:0" ] || \
+    log_fail "UID/GID is persisted mapped: expected 0:0, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/dir/first_end.txt")
+[ "$owner" == "9999:9999" ] || \
+    log_fail "UID/GID is persisted mapped: expected 9999:9999, got $owner"
+
+# Second map entry
+owner=$(stat -c %u:%g "$FSDIR/dir/second_start.txt")
+[ "$owner" == "10000:10000" ] || \
+    log_fail "UID/GID is persisted mapped: expected 10000:10000, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/dir/second_end.txt")
+[ "$owner" == "19999:19999" ] || \
+    log_fail "UID/GID is persisted mapped: expected 19999:19999, got $owner"
+
+# Third map entry
+owner=$(stat -c %u:%g "$FSDIR/dir/third_start.txt")
+[ "$owner" == "20000:20000" ] || \
+    log_fail "UID/GID is persisted mapped: expected 20000:20000, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/dir/third_end.txt")
+[ "$owner" == "29999:29999" ] || \
+    log_fail "UID/GID is persisted mapped: expected 29999:29999, got $owner"
+
+# Last map entry
+owner=$(stat -c %u:%g "$FSDIR/dir/last_start.txt")
+[ "$owner" == "30000:30000" ] || \
+    log_fail "UID/GID is persisted mapped: expected 30000:30000, got $owner"
+
+owner=$(stat -c %u:%g "$FSDIR/dir/last_end.txt")
+[ "$owner" == "65535:65535" ] || \
+    log_fail "UID/GID is persisted mapped: expected 65535:65535, got $owner"
+
+log_pass
-- 
2.20.1

