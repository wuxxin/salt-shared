{% load_yaml as defaults %}

config:
  # /etc/containers/containers.conf
  containers:
    containers:
      default_capabilities:
        - "CHOWN"
        - "DAC_OVERRIDE"
        - "FOWNER"
        - "FSETID"
        - "KILL"
        - "NET_BIND_SERVICE"
        - "SETFCAP"
        - "SETGID"
        - "SETPCAP"
        - "SETUID"
        - "SYS_CHROOT"
      default_sysctls:
        - "net.ipv4.ping_group_range=0 0"
    engine:
      # Container Runtime: ["crun", "runc", "kata"]
      # crun: OCI runtime with support for cgroup V2
      runtime: "crun"

  # /etc/containers/storage.conf
  storage:
    storage:
      # Primary storage driver
      driver: "overlay"

      # storage options
      options:
        overlay:
          mount_program: "/usr/bin/fuse-overlayfs"

  # /etc/containers/mounts.conf
  mounts:
    # Global Mounts: The format of the mounts.conf is the volume format /SRC:/DEST,
    # one mount per line. For example, a mounts.conf with the line
    # - "/usr/share/secrets:/run/secrets"
    # would cause the contents of the /usr/share/secrets directory on the host
    # to be mounted on the /run/secrets directory inside the container.
    # Setting mountpoints allows containers to use the files of the host.
    mounts: []

  # /etc/containers/policy.json
  policy:
    # Policy: Manages which registries you trust as a source of container images based on its location.
    # The location is determined by the transport and the registry host of the image.
    # Using this container image docker://docker.io/library/busybox as an example,
    #   docker is the transport and docker.io is the registry host.
    default:
      - type: insecureAcceptAnything
    transports:
      "docker-daemon":
        "":
          - type: insecureAcceptAnything

# used in containers/podman/init.sls and containers/podman/lib.sls
podman:
  workdir_basepath: /etc/containers/podman.service
  build_basepath: /var/lib/containers/podman-build
  user_workdir_basepath: "${HOME}/.config/podman.service"
  user_build_basepath: "${HOME}/.local/lib/podman-build"

compose:
  workdir_basepath: /etc/containers/podman-compose.service
  build_basepath: /var/lib/containers/podman-compose-build
  user_workdir_basepath: ${HOME}/.config/podman-compose.service
  user_build_basepath: ${HOME}/.local/lib/podman-compose-build
  compose_filename: docker-compose.yml
  override_filename: docker-compose.override.yml
  env_filename: .env

systemd:
  service_basepath: /etc/systemd/system
  user_service_basepath: ${HOME}/.config/systemd/user

x11docker:
  default:
    - --podman
    - --xpra
  host:
    - --podman
    - --cap-default
    - --hostdisplay
    - --clipboard
    - --gpu
    - --hostipc
    # - --verbose
    # - --webcam

external:
  "containerd.tar.gz":
    version: 1.5.0
    latest: curl -L -s -o /dev/null -w "%{url_effective}" "https://github.com/containerd/containerd/releases/latest" | sed -r "s/.*\/v([^\/]+)$/\1/"
    download: "https://github.com/containerd/containerd/releases/download/v##version##/containerd-##version##-linux-amd64.tar.gz"
    hash_url: "https://github.com/containerd/containerd/releases/download/v##version##/containerd-##version##-linux-amd64.tar.gz.sha256sum"
    target: /usr/local/lib/containerd.tar.gz
  "cri-containerd-cni.tar.gz":
    version: 1.5.0
    latest: curl -L -s -o /dev/null -w "%{url_effective}" "https://github.com/containerd/containerd/releases/latest" | sed -r "s/.*\/v([^\/]+)$/\1/"
    download: "https://github.com/containerd/containerd/releases/download/v##version##/cri-containerd-cni-##version##-linux-amd64.tar.gz"
    hash_url: "https://github.com/containerd/containerd/releases/download/v##version##/cri-containerd-cni-##version##-linux-amd64.tar.gz.sha256sum"
    target: /usr/local/lib/cri-containerd-cni.tar.gz

{% endload %}


{% load_yaml as default_container %}
# name of the container pod, systemd service, systemd oneshot
name:

# env: SERVICE_NAME will be set to name
# workdir: will be set to settings.podman.[user_]workdir_basepath+ "/"+ name
# builddir: will be set to settings.podman.[user_]build_basepath+ "/"+ name
# servicedir: will be set to /etc/systemd/system or ${HOME}/.config/systemd/user

# type: "build", "service", "oneshot"
# build   = build or pull image only, will not generate a systemd service
# service = create and start command as a systemd service
# oneshot = create a systemd oneshot execute script
type: service

# enabled: if false, service will be stopped, config files are removed
enabled: true
# update: if true, container image will be pulled/build on every service start
update: true
# ephemeral (service, oneshot): remove existing container before start
ephemeral: true
# absent (service, oneshot): if true also remove systemd service files
absent: false
# Set the user namespace mode for the container. options are "pick","auto","host","private"
# pick is analog to systemd nspawn and computes starting host_uid based on the container name hash
userns: auto

# systemd restart: "no, on-failure, on-success, on-abnormal, on-watchdog, on-abort, or always"
# default: "no" if type oneshot, else "on-failure"
restart: ""
# after, requires, wants: equal to systemd config
after: ""
requires: ""
wants: ""
# additional systemd properties
properties: {}

# name of the container image: x/y[:z]
image:
# optional tag, will be appended to image and on build time
tag:
# build: if source != "", build container with args using "podman build <source>"
build:
  source: ""
  args: {}
# options: dict: {key: value,} container options parameter for podman run
options: {}

# files to be placed inside workdir, which will be available via "./"
files: {}
{# Example:
  test.file:
    mode: "600"
    contents: |
      this is the content
  still.some.file:
    source: salt://containers/test.file
    template: jinja
    # specify any file.managed attribute, environment will be put into context
    defaults:
      custom: this is a custom var that will be available in the jinja context
#}

# environment: dict: {key: value,} add environment data
# environment will be populated with SERVICE_NAME which is constructed using servicename + "_" + profilename
environment: {}
# label: dict: {key: value,} add label to container
labels: {}
# storage: create volumes from list: - {name: volume_name, labels=[], driver: local, opts=[]}
storage: []
# volume: list: - [source-volume|host-dir:]container-dir[:options]
volumes: []
# ports: list
ports: []

# command: if set, will replace default command
command: ""
# args: if set, will add args for command, command must also be set
args: ""
# additional commands run on certain events
hook:
  initial:
    # commands run before the first time the service is started
    environment: {}
    command: ""
  update:
    # commands run after updating image to newer image before starting new image
    environment: {}
    command: ""
{% endload %}


{% load_yaml as default_compose %}
# name of the compose sevice and name of the controlling systemd service
name:

# env:SERVICE_NAME will be set to name
# workdir: will be set to settings.compose.[user_]workdir_basepath+ "/"+ name
# builddir: will be set to settings.compose.[user_]build_basepath+ "/"+ name
# servicedir: will be set to /etc/systemd/system or ${HOME}/.config/systemd/user

# type: "service", "oneshot", "command"
# service = make and start command as a systemd service
# oneshot = make a systemd oneshot execute script
# command = make a "oneshot" /usr/local/bin , ~/.local/bin script
type: service

# enabled: if false, service will be stopped, config files are removed
enabled: true
# update: if true, container image will be pulled/build on every service start
update: true
# absent (service, oneshot): if absent is true also remove systemd service files
absent: false
# Set the user namespace mode for the container. options are "pick","auto","host","private"
# pick is analog to systemd nspawn and computes starting host_uid based on the container name hash
userns: auto

# systemd restart: "no, on-failure, on-success, on-abnormal, on-watchdog, on-abort, or always"
# default: "no" if type oneshot, else "on-failure"
restart: ""
# after, requires, wants: equal to systemd config
after: ""
requires: ""
wants: ""
# additional systemd properties
properties: {}

# environment to be placed as ".env" file inside workdir
environment: {}
# compose source config and compose overrides config
source:
config: {}

# workdir: will be set to settings.compose.[user_]workdir_basepath+ "/"+ compose.name
# builddir: will be set to settings.compose.[user_]build_basepath+ "/"+ compose.name
# servicedir: will be set to /etc/systemd/system or ${HOME}/.config/systemd/user

# files to be placed inside workdir
files: {}
{# Examples: see container_defaults #}

# additional commands run on first or update executions
hook:
  initial:
    # commands run before the first time the service is started
    environment: {}
    command: ""
  update:
    # commands run after updating image to newer image before starting new image
    environment: {}
    command: ""
{% endload %}


{%- set settings = salt['grains.filter_by']({'default': defaults},
  grain='default', default= 'default', merge= salt['pillar.get']('containers', {})) %}

{# expand ##version## in field external.*.download #}
{% for n,v in settings.external.items() %}
  {% set download=settings.external[n]['download']|regex_replace('##version##', v.version) %}
  {% do settings.external[n].update( {'download': download} ) %}
  {% if settings.external[n]['hash_url'] %}
    {% set hash_url=settings.external[n]['hash_url']|regex_replace('##version##', v.version) %}
    {% do settings.external[n].update( {'hash_url': hash_url} ) %}
  {% endif %}
{% endfor %}
