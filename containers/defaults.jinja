{% load_yaml as defaults %}

# used in containers/init.sls and containers/lib.sls
container:
  service_basepath: /etc/containers/podman.service
  build_basepath: /var/lib/containers/podman-build
  user_service_basepath: ""
  user_build_basepath: ""

compose:
  service_basepath: /etc/containers/podman-compose.service
  build_basepath: /var/lib/containers/podman-compose-build
  compose_filename: docker-compose.yml
  override_filename: docker-compose.override.yml
  env_filename: .env

desktop:
  default:
    - --podman
    - --xpra
  host:
    - --podman
    - --cap-default
    - --hostdisplay
    - --clipboard
    - --gpu
    - --hostipc
    # - --verbose
    # - --webcam

# part of /etc/containers/containers.conf:[engine]
engine:
  # Container Runtime: ["runc"(default), "crun"]
  # crun: alternative OCI runtime with support for cgroup V2
  runtime: "crun"
  # Directory for libpod named volumes. Default:
  volume_path: "/var/lib/containers/storage/volumes"

# part of /etc/containers/storage.conf
storage:
  # Primary storage driver
  driver: "overlay"

  # Primary Read/Write location of container storage
  graphroot: "/var/lib/containers/storage"

  # Storage path for rootless users
  rootless_storage_path : "$HOME/.local/share/containers/storage"

  # storage options
  options:
    overlay:
      mount_program: "/usr/bin/fuse-overlayfs"

# part of /etc/containers/mounts.conf
# Global Mounts: The format of the mounts.conf is the volume format /SRC:/DEST,
# one mount per line. For example, a mounts.conf with the line
# - "/usr/share/secrets:/run/secrets"
# would cause the contents of the /usr/share/secrets directory on the host
# to be mounted on the /run/secrets directory inside the container.
# Setting mountpoints allows containers to use the files of the host.
mounts: []

# /etc/containers/policy.json
# Policy: Manages which registries you trust as a source of container images based on its location.
# The location is determined by the transport and the registry host of the image.
# Using this container image docker://docker.io/library/busybox as an example,
#   docker is the transport and docker.io is the registry host.
policy: |
    { "default": [ { "type": "insecureAcceptAnything" } ],
      "transports": {
        "docker-daemon": { "": [{"type":"insecureAcceptAnything"}] }
      }
    }

{% endload %}


{% load_yaml as default_container %}
# name of the container pod and name of the controlling systemd service
name:
# enabled: if false, service will be stopped, config files are removed, but service is kept
enabled: true
# absent: if absent is true also remove systemd service files
absent: false
# update: if true, container image will be pulled/build on every service start
update: true
# ephemeral: if set true, existing container will be removed on start
ephemeral: true

# type: "build", "exec", "oneshot" or "desktop"
# build = will build or pull image only, will not generate a systemd service
# exec = start command as a systemd service, oneshot = execute script as systemd oneshot
type: exec
# type: desktop
# # install desktop files for user to call as user application
# # desktop:user is mandatory, desktop options are passed to x11docker, defaulting to desktop.default
desktop:
  # user: username
  options: []
  entry: {}

# ### systemd service options (if type = exec|oneshot)
# systemd restart: "no, on-failure, on-success, on-abnormal, on-watchdog, on-abort, or always"
# default: "no" if type oneshot, else "on-failure"
restart: ""
# after, requires, wants: equal to systemd config
after: ""
requires: ""
wants: ""
# additional systemd properties
properties: {}

# name of the container image: x/y[:z]
image:
# optional tag, will be appended to image and on build time
tag:
# build: if source != "", build container with args using "podman build <source>"
build:
  source: ""
  args: {}
  # builddir: automatical set at buildtime to directory where build files are located
# files to be placed inside workdir, which will be available via "./"
files: {}
{# Example:
  test.file:
    mode: "600"
    contents: |
      this is the content
  still.some.file:
    source: salt://containers/test.file
    template: jinja
    # specify any file.managed attribute, environment will be put into context
    defaults:
      custom: this is a custom var that will be available in the jinja context
#}
# exec:firstrun: commands run if type=exec before the first time the service is started
# exec:updaterun commands run if type=exec after updating image to newer image before starting new image
exec:
  firstrun: []
  udpaterun: []
# Set the user namespace mode for the container. options are "pick","auto","host","private"
# pick is analog to systemd nspawn and computes starting host_uid based on the container name hash
userns: host

# environment: dict: {key: value,} add environment data
environment: {}
# environment will be populated with SERVICE_NAME which is constructed using servicename + "_" + profilename
# label: dict: {key: value,} add label to container
labels: {}
# storage: create volumes from list: - {name: volume_name, labels=[], driver: local, opts=[]}
storage: []
# volume: list: - [source-volume|host-dir:]container-dir[:options]
volumes: []
# ports: list
ports: []
# command: if set, will replace default command
command: ""
# args: if set, will add args for command, command must also be set
args: ""
# options: dict: {key: value,} container options parameter for podman run
options: {}

{% endload %}


{% load_yaml as default_compose %}
# name of the compose sevice and name of the controlling systemd service
name:

# enabled: if false, service will be stopped, config files are removed, but service is kept
enabled: true
# absent: if absent is true also remove systemd service files
absent: false
# update: if true: container image will be pulled/build on every service start
update: true
# config type: must be "compose", to make compose/container missmatch detectable
type: compose

# ### systemd service options
# systemd restart: "no, on-failure, on-success, on-abnormal, on-watchdog, on-abort, or always"
restart: on-failure
# after, requires, wants: equal to systemd config
after: ""
requires: ""
wants: ""
# additional systemd properties
properties: {}

# environment to be placed as ".env" file inside workdir
environment: {}
# compose source config and compose overrides config
source:
config: {}
# workdir: if empty will use settings.compose.service_basepath+ "/"+ compose.name
workdir:
# builddir: automatical set at buildtime to directory where build files are located
# files to be placed inside workdir
files: {}
{# Examples: see container_defaults #}
# exec:firstrun: commands run if type=exec before the first time the service is started
# exec:updaterun commands run if type=exec after updating image to newer image before starting new image
exec:
  firstrun: []
  udpaterun: []
# Set the user namespace mode for the container. options are "pick","auto","host","private"
# pick is analog to systemd nspawn and computes starting host_uid based on the container name hash
userns: host
{% endload %}


{%- set settings = salt['grains.filter_by']({'default': defaults},
  grain='default', default= 'default', merge= salt['pillar.get']('containers', {})) %}
